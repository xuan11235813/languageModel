import math as mt 
import para
import numpy as np

class GenerateSamples:
	def __init__(self, mode  = ''):
		print('ready to generate samples')
		self.targetNum = 0
		self.sourceNum = 0
		parameters = para.Para()
		self.lexiconNetPara = parameters.LexiconNeuralNetwork(mode)
		self.alignmentNetPara = parameters.AlignmentNeuralNetwork()
		self.bias = parameters.GetTargetSourceBias()

	def getLSTMLexiconSample(self, sentencePair):
		self._sentencePair = sentencePair
		self.targetNum = len(sentencePair._target)
		self.sourceNum = len(sentencePair._source)

		samples = []
		labels = []

		# add an zero point with target bias to start of target
		# for a sentence pair with 5 source words and 6 target words
		# |s1|s2|s3|s4|s5|t0(zeros point)|t1|t2|t3|t4|t5|
		# it is because we use s1-sn and t1-t(n-1)  to generate prediction of tn
		for i in range( self.sourceNum ):
			samples.append(sentencePair._source[i])
		samples.append(self.bias)
		for i in range( self.targetNum  - 1):
			samples.append(sentencePair._target[i] + self.bias)

		for i in range( self.targetNum ):
			for j in range( self.sourceNum ):
				labels.append(sentencePair._target[i])
				#labels.append(sentencePair._targetClass[i])
		return samples, labels

	def getLSTMAlignmentSample(self, sentencePair):
		self._sentencePair = sentencePair
		self.targetNum = len(sentencePair._target)
		self.sourceNum = len(sentencePair._source)

		samples = []
		# sn can be generated by s1-s(n-1) and t1-t(n-1)
		# shoud be remember that the alignment samples always have n-1 groups. 
		# the first sample should be from s1 and t1 to s2
		# |s1|s2|s3|s4|s5|t1|t2|t3|t4|t5|
		# though from examples we have 6 target words here we only use 5
		for i in range( self.sourceNum ):
			samples.append(sentencePair._source[i])
		for i in range( self.targetNum  - 1):
			samples.append(sentencePair._target[i] + self.bias)
		return samples

	def getLabelFromGamma( self, alignmentGamma, lexiconGamma, sentencePair):
		alignmentLabel = np.zeros([(self.targetNum - 1) * self.sourceNum, self.alignmentNetPara.GetJumpLabelSize()])
		initialAlignmentLabel = np.zeros(self.alignmentNetPara.GetJumpLabelSize())
		lexiconLabel = np.zeros([self.targetNum * self.sourceNum, self.lexiconNetPara.GetLabelSize()])
		center = int(self.alignmentNetPara.GetJumpLabelSize()/2)
		
		# create lexicon label
		for i in range(self.targetNum):
			for j in range(self.sourceNum):
				#lexiconLabel[i * self.sourceNum + j][sentencePair._targetClass[i]] = lexiconGamma[i][j]
				#lexiconLabel[i * self.sourceNum + j][sentencePair._target[i]] = lexiconGamma[i][j]
				lexiconLabel[i * self.sourceNum + j][sentencePair._target[i]] = 1
		# create alignment label
		jumpLimited = self.alignmentNetPara.GetJumpLimited()
		for i in range(self.targetNum  - 1):
			for j in range(self.sourceNum):
				for j_ in range(self.sourceNum):
					if abs(j_ -j) <= jumpLimited:
						alignmentLabel[i*self.sourceNum + j][j_ - j + center] = alignmentGamma[i*self.sourceNum +j][j_]

		# initial state probability
		for i in range(center, min(self.alignmentNetPara.GetJumpLabelSize(), center + self.sourceNum)):
			initialAlignmentLabel[i] = lexiconGamma[0][i - center]

		return lexiconLabel, alignmentLabel, initialAlignmentLabel

	def getUnitTestlabel(self, sentencePair):
		alignmentLabel = np.zeros([(self.targetNum - 1) * self.sourceNum, self.alignmentNetPara.GetJumpLabelSize()])
		lexiconLabel = np.zeros([self.targetNum * self.sourceNum, self.lexiconNetPara.GetLabelSize()])
		center = int(self.alignmentNetPara.GetJumpLabelSize()/2)
		for i in range(self.targetNum):
			for j in range(self.sourceNum):
				#lexiconLabel[i * self.sourceNum + j][sentencePair._targetClass[i]] = 1
				lexiconLabel[i * self.sourceNum + j][sentencePair._target[i]] = 1
		return lexiconLabel

	# ------------------------------These functions will be deprecated later ---------------------------------------
	# samples with class and inner class index
	def getLexiconSamples( self, sentencePair ):
		self._sentencePair = sentencePair
		self.targetNum = len(sentencePair._target)
		self.sourceNum = len(sentencePair._source)
		samples = []
		labels = []
		for i in range(self.targetNum):
			for j in range(self.sourceNum):
				lexiconSourceStart = int(j - mt.floor(self.lexiconNetPara.GetLexiconSourceWindowSize()/2))
				lexiconSourceEnd = int(lexiconSourceStart + self.lexiconNetPara.GetLexiconSourceWindowSize())
				lexiconTargetStart = int(i - self.lexiconNetPara.GetLexiconTargetWindowSize())
				lexiconTargetEnd = int(lexiconTargetStart + self.lexiconNetPara.GetLexiconTargetWindowSize())
				itemSample = []
				itemLabel = []

				for s in range(lexiconSourceStart, lexiconSourceEnd):
					if (s < 0) | (s >= self.sourceNum):
						itemSample.append(0)
					else:
						itemSample.append(sentencePair._source[s])
				for t in range(lexiconTargetStart, lexiconTargetEnd):
					if (t < 0) | (t >= self.targetNum):
						itemSample.append(0)
					else:
						itemSample.append(sentencePair._target[t] + self.bias)
				#itemLabel.append(sentencePair._targetClass[i])
				itemLabel.append(sentencePair._target[i])
				itemLabel.append(sentencePair._innerClassIndex[i])
				samples.append(itemSample)
				labels.append(itemLabel)
		return samples, labels

	# samples with simplest label (only target class index)
	def getSimpleLexiconSamples(self, sentencePair):
		self._sentencePair = sentencePair
		self.targetNum = len(sentencePair._target)
		self.sourceNum = len(sentencePair._source)
		samples = []
		labels = []
		for i in range(self.targetNum):
			for j in range(self.sourceNum):
				lexiconSourceStart = int(j - mt.floor(self.lexiconNetPara.GetLexiconSourceWindowSize()/2))
				lexiconSourceEnd = int(lexiconSourceStart + self.lexiconNetPara.GetLexiconSourceWindowSize())
				lexiconTargetStart = int(i - self.lexiconNetPara.GetLexiconTargetWindowSize())
				lexiconTargetEnd = int(lexiconTargetStart + self.lexiconNetPara.GetLexiconTargetWindowSize())
				itemSample = []

				for s in range(lexiconSourceStart, lexiconSourceEnd):
					if (s < 0) | (s >= self.sourceNum):
						itemSample.append(0)
					else:
						itemSample.append(sentencePair._source[s])
				for t in range(lexiconTargetStart, lexiconTargetEnd):
					if (t < 0) | (t >= self.targetNum):
						itemSample.append(0)
					else:
						itemSample.append(sentencePair._target[t] + self.bias)
				samples.append(itemSample)
				#labels.append(sentencePair._targetClass[i])
				labels.append(sentencePair._target[i])
		return samples, labels

	def getAlignmentSamples(self, sentencePair):
		self._sentencePair = sentencePair
		self.targetNum = len(sentencePair._target)
		self.sourceNum = len(sentencePair._source)
		samples = []
		initialSample = []
		for i in range(self.targetNum - 1):
			for j in range(self.sourceNum):
				alignmentSourceStart = int(j - mt.floor(self.alignmentNetPara.GetAlignmentSourceWindowSize()/2))
				alignmentSourceEnd = int(alignmentSourceStart + self.alignmentNetPara.GetAlignmentSourceWindowSize())
				# should be really cautious about the index of alignment
				# the end point will not be reached by using function range()
				alignmentTargetStart = int(i - self.alignmentNetPara.GetAlignmentTargetWindowSize()) + 1
				alignmentTargetEnd = int(alignmentTargetStart + self.alignmentNetPara.GetAlignmentTargetWindowSize())
				itemSample = []

				for s in range(alignmentSourceStart, alignmentSourceEnd):
					if (s < 0) | (s >= self.sourceNum):
						itemSample.append(0)
					else:
						itemSample.append(sentencePair._source[s])
				for t in range(alignmentTargetStart, alignmentTargetEnd):
					if (t < 0) | (t >= self.targetNum):
						itemSample.append(0)
					else:
						itemSample.append(sentencePair._target[t] + self.bias)

				samples.append(itemSample)

		# generate the whole zero sample
		for i in range(self.alignmentNetPara.GetAlignmentSourceWindowSize()):
			initialSample.append(0)
		for i in range(self.alignmentNetPara.GetAlignmentTargetWindowSize()):
			initialSample.append(0 + self.bias)

		return samples, initialSample
		
	

